%==============================================================================
\section{DeltaSort Algorithm}
\label{sec:algorithm}
%==============================================================================

\subsection{Overview}

DeltaSort operates in two phases. The first phase establishes a structure among updated values, and the second phase exploits this structure to efficiently sort the array.

\paragraph{Phase 1: Establish structure} DeltaSort begins by extracting the values at the updated indices, sorting them, and writing them back into the array in increasing index order. This step enforces order among updated positions: if $i < j$ are both updated indices, then $A[i] \le A[j]$ (according to \texttt{cmp}) after Phase~1. This monotonicity implies that any remaining disorder must occur only between updated values and their unchanged neighbours. Moreover, it induces a simple directional structure on the updated indices, which we formalize next.

\begin{definition}[Direction]
\label{def:direction}
For an index $i \in U$, we define its \emph{direction} based on local order:
\begin{itemize}
  \item \textbf{LEFT ($L$)}: Value is ordered incorrectly to its left neighbour: $i > 0 \text{ and } A[i-1] > A[i]$
  \item \textbf{RIGHT ($R$)}: Value is either already sorted correctly w.r.t its neighbours or ordered incorrectly to its right neighbour: $i = 0 \text{ or } A[i-1] \le A[i]$
\end{itemize}
\end{definition}

The notion of direction is not defined and irrelevant for indices $i \notin U$. Also note that the definition of direction is asymmetric. $L$ requires a strict violation ($A[i-1] > A[i]$), while $R$ includes both violating and non-violating cases. This is deliberate because DeltaSort treats all $R$ values identically, so combining these cases simplifies the implementation (see \algoref{alg:deltasort}).

After Phase~1, updated indices group into \emph{segments}, which we define next.

\begin{definition}[Segment]
\label{def:segment}
A \emph{segment} is a pair of indices $(i, j)$ with $i < j$ such that:
\begin{enumerate}
  \item Either $i = 0$, or $i \in U$ has direction $R$.
  \item Either $j = n - 1$, or $j \in U$ has direction $L$.
  \item There exist no updated indices $p, q \in U$ with $i < p < q < j$ such that $p$ is $L$ and $q$ is $R$.
  \item There exist no updated indices $p < i$ and $q > j$ such that $(p, q)$ is also a segment.
\end{enumerate}
\end{definition}

Intuitively, a segment is a maximal contiguous region of the array in which all $R$-direction updates precede all $L$-direction updates. The first two conditions define valid segment boundaries, the third enforces the $R^\ast L^\ast$ structure within a segment, and the final condition ensures that segments are maximal and non-overlapping. \figref{fig:segment-structure} illustrates this structure.

\input{\figdir/segment-structure}

\paragraph{Phase 2: Fix segments}
With the above structure in place, DeltaSort fixes the array segment by segment. Within each segment, updated indices are processed in increasing index order. For each segment, the algorithm maintains two boundaries: a left boundary $\ell$ beyond which the $L$-values cannot move and a right boundary $r$ beyond which the $R$-values cannot move.

\begin{enumerate}
  \item At the start of a segment, the left boundary $\ell$ is initialized to the segment's left endpoint.
  \item As the algorithm scans updated indices from left to right, indices with direction $R$ are pushed onto a stack.
  \item When the first $L$-direction index at position $i$ is encountered or the end of the segment is reached, the right boundary $r$ is initialized to $i$. All deferred $R$ indices are then fixed in LIFO order. Each $R$ value with index $i$ is fixed using binary insertion within the range $[i, r]$, after which $r$ is advanced to the left beyond the insertion position.
  \item After all deferred $R$ values have been fixed, $L$ values are fixed in left-to-right order. Each $L$ value at index $i$ is fixed using binary insertion within the range $[\ell, i]$, after which the left boundary $\ell$ is advanced to the right beyond the insertion position.
\end{enumerate}

Importantly, the binary search ranges for $L$ and $R$ fixes are always within the current segment boundaries. Figure~\ref{fig:delta-sort-example} illustrates this process for a sample array.

\input{\figdir/delta-sort-example}

\subsection{Key Insight: Segments can be fixed locally and independently}
\label{sec:insight}

The key insight behind DeltaSort is that segments created after Phase~1 can be fixed locally. Unlike BIS, where each insertion can be at any point in the array, an updated value in a segment cannot cross its segment boundary. We formally prove this property next.

\begin{lemma}[Direction Invariance]
\label{lem:direction-invariance}
After Phase~1, each updated value moves only in the direction indicated by its direction label:
\begin{itemize}
  \item Values with direction $L$ \textbf{must} move to the left.
  \item Values with direction $R$ \textbf{may} \footnote{This asymmetry follows from the definition of direction (Definition~\ref{def:direction}).} move to the right.
\end{itemize}
\end{lemma}

\begin{proof} Consider an updated index $i$. If $i$ has direction $R$, then by definition either $i = 0$ or $\texttt{cmp}(A[i-1], A[i]) \le 0$. After Phase~1, updated values are written back in sorted order by index, so all updated values to the left of $i$ are less than or equal to $A[i]$. All unchanged values to the left were already in sorted order. Hence, no value to the left of $i$ exceeds $A[i]$, and $A[i]$ cannot move left during Phase~2. The argument for direction $L$ is symmetric.
\end{proof}

\begin{lemma}[Movement Confinement]
\label{lem:confinement}
During Phase~2, all value movement is confined within segment boundaries.
\end{lemma}

\begin{proof}
Let $S$ be a segment with $R$-indices
$R_0,\ldots,R_{r-1}$ followed by $L$-indices
$L_0,\ldots,L_{l-1}$, where $r+l \ge 1$.
After Phase~1,
\[
A[R_0] \le \cdots \le A[R_{r-1}] \le A[L_0] \le \cdots \le A[L_{l-1}].
\]

By Lemma~\ref{lem:direction-invariance}, $R$-values move only rightward and $L$-values move only leftward. An $R$-value cannot cross $L_0$ (if it exists), and an $L$-value cannot cross $R_{r-1}$ (if it exists), since the above ordering is preserved. Therefore, no value exits its segment.
\end{proof}

\begin{remark}
  Note that Lemma~\ref{lem:confinement} also implies \emph{segment independence}. Because no value exits its segment, segment lengths don't change. As a result, movement in a segment does not interfere with movement in another segment, which implies segments can be fixed independently in any order. This opens up opportunities for \textbf{parallelization} with degree of parallelism \emph{proportional to the number of segments}. This can improve performance even further on multi-core systems or distributed environments. To avoid scope creep, we leave this investigation for future work.
\end{remark}

\subsection{Correctness Proof}

\begin{lemma}[Fix Invariant]
\label{lem:fix-invariant}
Each fix operation during Phase~2 resolves an order violation without introducing new ones.
\end{lemma}

\begin{proof}
We fix each violation using binary search. For binary search to find the correct insertion point, the search range must contain no violations.
\begin{itemize}
    \item \emph{L fix at index $i$}: The search range $[leftBound, i-1]$ contains no L violations because Ls are processed left-to-right, and no R violations because all pending Rs are flushed before any L is fixed.
    \item \emph{R fix at index $i$}: The search range $[i+1, rightBound]$ contains no R violations because Rs are processed in LIFO order with $rightBound$ narrowing after each fix, and no L violations because $rightBound$ never extends past the first L in the segment.
\end{itemize}
\end{proof}

\begin{theorem}[Correctness]
\label{thm:correctness}
DeltaSort produces a correctly sorted array.
\end{theorem}

\begin{proof}
The only violations in the array after Phase~1 are at updated indices. Phase~2 processes each updated index exactly once. By \lemref{lem:fix-invariant}, each fix resolves a violation without introducing new ones. After all fixes, no violations remain, so the array is sorted.
\end{proof}

\subsection{Complexity Analysis}
\label{sec:complexity}

We analyse the expected total data movement incurred during Phase~2 of DeltaSort under a random bounded-range update model. In this model, updated values are drawn uniformaly at random from a \emph{fixed} value range. Choosing values at random avoids introducing any special structure that could bias the analysis.

\begin{remark}[Choice of Update Model]
\label{rem:update-model}
Several update models could be considered. For example, a \emph{bounded rank displacement} model constrains updates such that for every updated value $|Rank_{\text{new}} - Rank_{\text{old}}| \le b$ for some bound $b$, while a \emph{clustered update} model restricts updated indices to a region with $u_{\max} - u_{\min} \le c$. Different models interact with DeltaSortâ€™s structure in different ways: bounded displacement directly limits movement and is therefore favorable, whereas clustered updates may either help or hinder performance depending on the induced directional pattern. In this work, we adopt a \emph{random update model} as a neutral baseline. Specifically, updated indices are chosen uniformly at random from $\{0, \ldots, n-1\}$, and updated values are drawn independently from a fixed range of permissible values. This model introduces no additional structure that the algorithm can exploit, nor does it adversarially bias updates towards worst-case configurations (see \figref{fig:worst-case} for an example of a worst case). Analyzing DeltaSort under more structured update models, including bounded displacement and clustered updates, is left to future work.
\end{remark}

\begin{lemma}[Expected Linear Movement]
\label{lem:movement-bound}
Under the random bounded-range update model, for an array of size $n$ with $k$ updated indices, the expected total data movement incurred during DeltaSort's Phase~2 is $O(n)$, independent of $k$.
\end{lemma}

\begin{proof}
Consider the sequence of directions induced by the $k$ updated indices after Phase~1. Under the random update model, updated indices are chosen uniformly at random and hence are evenly distributed in expectation across the array. After Phase~1, the updated values are sorted and written back in index order, which enforces the correct order among updated values: for consecutive updated indices $u_\ell < u_i < u_r$, the value at $u_i$ must lie between $A[u_{\ell}]$ and $A[u_r]$.

For an updated index $u_i$ to be classified as $L$, it must be in the range $[A[u_\ell], A[u_i-1]]$. Similarly, for it to be classified as $R$, it must be in the range $[A[u_i-1], A[u_r]]$. Given the updated indices are distributed uniformly at random, both these intervals are expected to be of equal size on average. Each updated value, randomly chosen, has equal probability to lie in either range. Therefore, each updated index has direction $L$ or $R$ with equal probability $1/2$, independently.

It follows from \defref{def:direction} that segment boundaries occur at $\mathrm{L}\!\to\!\mathrm{R}$ transitions in the direction sequence. For any adjacent pair of updated indices $(i, i+1)$:
\[
\Pr[\mathrm{LR} \text{ at } (i, i+1)] = \Pr[\text{L at } i] \cdot \Pr[\text{R at } i+1] = \frac{1}{2} \cdot \frac{1}{2} = \frac{1}{4}.
\]

With $k-1$ adjacent pairs, the expected number of $\mathrm{L}\!\to\!\mathrm{R}$ transitions is:
\[
\mathbb{E}[\text{LR transitions}] = (k-1) \cdot \frac{1}{4} = \frac{k-1}{4} = \Theta(k).
\]

The expected number of segments is therefore $1 + \Theta(k) = \Theta(k)$. Under uniform index distribution, each segment spans $O(n/k)$ positions in expectation. By \lemref{lem:confinement}, movement is confined within segments, so each updated value moves at most $O(n/k)$ positions. Thus:
\[
\mathbb{E}[\text{total movement}] \le k \cdot O(n/k) = O(n). \qedhere
\]
\end{proof}

\begin{remark}[Worst Case Movement]
While the expected movement is $O(n)$, the worst-case movement can be as high as $O(kn)$. This occurs when all updated values form a single segment spanning the entire array. This happens when updates cluster monotonically at the start and end of the array as shown in \figref{fig:worst-case}. Hence, in a practical setting, a hybrid algorithm will need to fallback to ESM or full re-sort based on the number of segments detected after Phase~1.
\input{\figdir/worst-case}
\end{remark}

\begin{lemma}[Comparison Count]
\label{lem:comparison-count}
DeltaSort performs $O(k \log n)$ comparisons.
\end{lemma}

\begin{proof}
Phase~1 sorts the $k$ updated values, requiring $O(k \log k)$ comparisons. In Phase~2, each updated value is fixed using binary search within its containing segment. By \lemref{lem:movement-bound}, the expected width of a segment is $O(n/k)$, and searches are confined within segment boundaries. Therefore, each fix requires $O(\log (n/k))$ comparisons, for a total of $O(k \log (n/k))$ comparisons in Phase~2. Summing both phases gives:
\[
O(k \log k) + O(k \log (n/k)) = O\!\bigl(k(\log k + \log (n/k))\bigr) = O(k \log n).
\]
\end{proof}

\begin{theorem}[Time Complexity]
\label{thm:time-complexity}
Under the random bounded-range update model, DeltaSort runs in $O(k \log n + n)$ expected time.
\end{theorem}

\begin{proof}
By \lemref{lem:movement-bound}, the expected total data movement is $O(n)$. By \lemref{lem:comparison-count}, the total number of comparisons is $O(k \log n)$. Combining these, the expected running time is $O(k \log n + n)$.
\end{proof}

\begin{theorem}[Space Complexity]
\label{thm:space}
DeltaSort uses $O(k)$ auxiliary space.
\end{theorem}

\begin{proof}
Phase~1 stores $k$ updated indices and $k$ updated values. Phase~2 maintains a pending stack of at most $k$ indices. The internal sorting routine is also assumed to use $O(k)$ space. Therefore, the total auxiliary space is $O(k)$.
\end{proof}

\subsection{Pseudocode}

\input{\figdir/pseudocode}