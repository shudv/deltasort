\begin{algorithm}[H]
\caption{DeltaSort}
\label{alg:deltasort}
\begin{algorithmic}[1]
\Require Array $A[0..n-1]$, updated indices $U$, comparator $\texttt{cmp}$
\Ensure $A$ is sorted
\Statex
\State \textbf{Phase 1: Establish segments}
\State $\texttt{updatedIndices} \gets \text{sort}(U)$;
\State $\texttt{updatedValues} \gets \text{sort}([A[u] : u \in \texttt{updatedIndices}], \texttt{cmp})$
\For{$i \gets 0$ \textbf{to} $|\texttt{updatedIndices}| - 1$}
\State $A[\texttt{updatedIndices}[i]] \gets \texttt{updatedValues}[i]$
\EndFor
\State $\texttt{updatedIndices.push}(n)$; \Comment{Sentinel for handling trailing segment with no LEFT's}
\Statex
\State \textbf{Phase 2: Fix segments}
\State $\texttt{pendingRight} \gets []$; $\texttt{leftBound} \gets 0$
\For{$p \gets 0$ \textbf{to} $|\texttt{updatedIndices}| - 1$}
    \State $i \gets \texttt{updatedIndices}[p]$; $\texttt{dir} \gets (i = n)$ ? \textsc{Left} : $\Call{GetDirection}{A, i}$
    \If{$\texttt{dir} = \textsc{Left}$}
        \State $\texttt{rightBound} \gets i - 1$
        \While{$\texttt{pendingRight} \neq \emptyset$}
            \State $j \gets \texttt{pendingRight.pop}()$
            \If{$\texttt{cmp}(A[j], A[j+1]) > 0$}
                \State $\texttt{rightBound} \gets \Call{FixRight}{A, j, \texttt{rightBound}} - 1$
            \EndIf
        \EndWhile
        \If{$i < n$} \Comment{Skip dummy LEFT sentinel}
            \State $\texttt{leftBound} \gets \Call{FixLeft}{A, i, \texttt{leftBound}} + 1$
        \EndIf
    \Else
        \State $\texttt{pendingRight.push}(i)$ \Comment{Defer RIGHT violation}
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

\vspace{0.5em}

\noindent\begin{minipage}{\linewidth}
\begin{algorithmic}[1]
\Function{GetDirection}{$A$, $i$}
    \State \Return $i > 0 \land \texttt{cmp}(A[i-1], A[i]) > 0$ ? \textsc{Left} : \textsc{Right}
\EndFunction
\end{algorithmic}
\end{minipage}

\vspace{0.5em}

\noindent\begin{minipage}{\linewidth}
\begin{algorithmic}[1]
\Function{FixLeft}{$A$, $i$, $\texttt{leftBound}$}
    \State $t \gets \Call{BinarySearchLeft}{A, A[i], \texttt{leftBound}, i-1}$
    \State \Call{Move}{A, i, t}
    \State \Return $t$
\EndFunction
\end{algorithmic}
\end{minipage}

\vspace{0.5em}

\noindent\begin{minipage}{\linewidth}
\begin{algorithmic}[1]
\Function{FixRight}{$A$, $i$, $\texttt{rightBound}$}
    \State $t \gets \Call{BinarySearchRight}{A, A[i], i+1, \texttt{rightBound}}$
    \State \Call{Move}{A, i, t};
    \State \Return $t$
\EndFunction
\end{algorithmic}
\end{minipage}