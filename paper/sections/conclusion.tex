%==============================================================================
\section{Conclusion}
\label{sec:conclusion}
%==============================================================================

This paper studied the problem of maintaining sorted arrays under incremental \emph{known} updates. We argued that this \emph{update-aware} setting arises naturally in many practical systems. Within this model, we presented \emph{DeltaSort}, an incremental sorting algorithm that batches multiple updates instead of applying them independently. The key idea is to exploit structure created by pre-sorting updated values, which induces directional segmentation and enables localized, non-overlapping fixes. This enables DeltaSort to reduce redundant data movement. Our theoretical analysis shows that DeltaSort matches the comparison efficiency of Binary-Insertion-Sort while exhibiting $O(n)$ data movement under random bounded-update model. Experimental results in Rust demonstrate that DeltaSort occupies a distinct space in the incremental sorting design spectrum: it outperforms Binary-Insertion-Sort for small update batches, is more space-efficient than Extract–Sort–Merge across a wider range of updates. Importantly, the results also highlight the limits of this approach. DeltaSort does not dominate existing techniques across all kinds of execution environments, and its advantages depend on predictable memory movement costs. For example, in managed runtimes and environments with less transparent memory layouts, these benefits may diminish.

Overall, this work shows that exposing update information to lower level sorting primitives enables new algorithmic trade-offs that are not available to blind sorting algorithms. DeltaSort demonstrates that even within array sorting, exposing modest additional structure yields new and practically relevant time–space trade-offs.
