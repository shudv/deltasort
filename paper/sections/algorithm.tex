%==============================================================================
\section{DeltaSort Algorithm}
\label{sec:algorithm}
%==============================================================================

\subsection{Overview}

DeltaSort is a conditionally \footnote{The stability and auxiliary space usage of DeltaSort depend solely on the sorting routine used in Phase~1 to order the $k$ updated values. Apart from this step, DeltaSort introduces no instability and requires no auxiliary space.} \emph{stable} \emph{in-place} update-aware sorting algorithm. It operates in two phases (see \algoref{alg:deltasort} for pseudocode). The first phase establishes a structure among updated values, and the second phase exploits this structure to efficiently sort the array.

\input{\figdir/pseudocode}

\paragraph{Phase 1: Establish structure} DeltaSort begins by extracting the values at the updated indices, sorting them, and writing them back into the array in increasing index order. This step enforces order among updated positions: if $i < j$ are both updated indices, then $A[i] \le A[j]$ (according to \texttt{cmp}) after Phase~1. The unchanged values are already in order by design. Hence, any remaining order violations must occur only between updated values and their unchanged neighbours.

\paragraph{Phase 2: Fix violations}
With the above structure in place, DeltaSort fixes the array one updated index at a time left to right. When an updated index is first encountered, we first determine its \emph{direction}:

\begin{definition}[Direction]
\label{def:direction}
During Phase~2, for an index $i \in U$, we define its \emph{direction} based on its local order with its left neighbour:
\begin{itemize}
  \item \textbf{LEFT ($L$)}: Value is ordered incorrectly to its left neighbour and hence \textbf{must} move left: $i > 0 \text{ and } A[i-1] > A[i]$
  \item \textbf{RIGHT ($R$)}: Value is ordered correctly to its left neighbour or its the first value and hence \textbf{may} move right: $i = 0 \text{ or } A[i-1] \le A[i]$
\end{itemize}
\end{definition}

A few things to note about this definition:
\begin{itemize}
  \item The notion of direction is not defined (or needed) for unchanged indices ($i \notin U$).
  \item Direction is determined only by the left neighbour because the array is guaranteed to be sorted to the left of $i$ by the time we encounter it.
  \item The definition of direction is asymmetric. $L$ requires a strict violation ($A[i-1] > A[i]$), while $R$ includes both violating and non-violating cases, as it may or may not violate order with its right neighbour. This is deliberate because DeltaSort treats all $R$ values identically, so combining these cases simplifies the implementation (see \algoref{alg:deltasort}).
\end{itemize}
 
Phase~2 (line ~9--29) processes updated indices from left to right while maintaining a growing sorted prefix. We describe Phase~2 by first establishing a loop invariant and then prove its correctness by showing that the invariant holds during initialization, maintenance, and termination.

\subparagraph{State:} We utilise following state information during Phase~2:
\begin{itemize}
  \item \texttt{updatedIndices}: Sorted list of updated indices with a sentinel $n$ appended at the end.
  \item \texttt{leftBound} ($\ell$): $0$
  \item \texttt{pendingRight}: $\phi$
\end{itemize}

\subparagraph{Loop invariant:} At the start of each iteration of the loop at line~10, the following conditions hold for index $p$:
\begin{enumerate}
  \item The subarray $A[0..\ell-1]$ is sorted and contains its final values.
  \item The stack contains pending $R$ indices within the range $[\ell, \texttt{updatedIndices}[p]-1]$.
  \item There are no $L$ violations in the range $[\ell, {updatedIndices}[p]-1]$.
  \item If the previous updated index had $L$ direction, then \texttt{pendingRight} is empty.
\end{enumerate}

\subparagraph{Initialization:} The invariant holds in the initial state:
\begin{itemize}
  \item $\ell = 0$ implies $A[0..\ell-1]$ is empty and hence sorted.
  \item For the same reason, \texttt{pendingRight} is empty.
  \item No updates have been processed yet, so there are no $L$ violations.
  \item No previous updated index exists, so condition (3) holds trivially.
\end{itemize}

\subparagraph{Maintenance:} We will now show that is the invariant holds at the start of the iteration for index $p$, it holds at the start of the next iteration for index $p+1$ as well. Let $i = \texttt{updatedIndices}[p]$ and $\texttt{dir} = \Call{GetDirection}{A, i}$.

\emph{Case 1: $\texttt{dir} = L$.}
\begin{enumerate}
  \item We first set $\texttt{rightBound} \gets i - 1$.
  \item We then flush all pending $R$ indices in LIFO order. Each $R$ index $j$ is fixed by binary insertion within the range $[j+1, \texttt{rightBound}]$, where $\texttt{rightBound}$ is updated after each fix to ensure that subsequent fixes do not interfere with already fixed values. By construction, this range contains no violations because:
    \begin{itemize}
      \item No $R$ violations exist because $R$s are processed in LIFO order with $\texttt{rightBound}$ narrowing after each fix.
      \item No $L$ violations exist because all pending $R$s are flushed before any $L$ is fixed.
    \end{itemize}
  \item After all $R$s are fixed, we fix the current $L$ index $i$ by binary insertion within $[\ell, i-1]$. This range contains no violations because:
    \begin{itemize}
      \item No $L$ violations exist because $L$s are processed left-to-right.
      \item No $R$ violations exist because all pending $R$s are flushed before any $L$ is fixed.
    \end{itemize}
  \item Finally, we set $\ell \gets$ (insertion point of $i$) $+ 1$.
\end{enumerate}

At the start of the next iteration, condition (1) holds because we have extended the sorted prefix to include the fixed $L$ value. Condition (2) holds because we have flushed all pending $R$s. Condition (3) holds because we have fixed all $L$ violations up to index $i$. Condition (4) holds because the current index had $L$ direction.

\emph{Case 2: $\texttt{dir} = R$.}

\begin{enumerate}
  \item If \texttt{pendingRight} is empty, this is the first $R$ in a new segment, so we set $\ell \gets i$.
  \item We then push $i$ onto \texttt{pendingRight} for deferred fixing.
\end{enumerate}

At the start of the next iteration, condition (1) holds because we have not modified the sorted prefix. Condition (2) holds because we have only added a new pending $R$ index within the current range. Condition (3) holds because we have not introduced any new $L$ violations. Condition (4) holds trivially because the current index had $R$ direction.

\subparagraph{Termination:} The loop processes all elements of \texttt{updatedIndices}, including the sentinel index $n$, which is treated as a $L$ direction. Substituting $p = n$ in the invariant conditions, we have:
\begin{itemize}
  \item Condition (1) implies that $A[0..\ell-1]$ is sorted and contains its final values.
  \item Condition (2) implies that all $R$ violations in range $A[\ell..n-1]$ are in \texttt{pendingRight}.
  \item Condition (3) implies that there are no $L$ violations in the range $[\ell, n-1]$.
  \item Condition (4) implies that \texttt{pendingRight} is empty, because the previous index was the sentinel $n$ with $L$ direction.
  \item Combining conditions (2), (3) and (4), we conclude that there are no violations in the range $[\ell, n-1]$.
  \item Combining that with condition (1), we have no violations in the entire array $A[0..n-1]$. Hence, the array is fully sorted.
\end{itemize}

Figure~\ref{fig:delta-sort-example} illustrates this sequence of operations for a sample array.
\input{\figdir/delta-sort-example}

To understand why this helps reduce data movement even though we are doing repeated binary insertions, we first formalise the structure that emerges from Phase~1. If we picture the updated indices arranged in a sequence of $L$ and $R$ labels, based on their direction when first encountered during Phase~2, we can partition them into \emph{segments}.


\begin{definition}[Segment]
\label{def:segment}
A \emph{segment} is a subarray of $A$ spanning indices $[i, j]$, where $0 \le i \le j < n$, such that:
\begin{enumerate}
  \item Either $i = 0$, or $i \in U$ and has direction label $R$.
  \item Either $j = n - 1$, or $j \in U$ and has direction label $L$.
  \item There exist no updated indices $p, q \in U$ with $i < p < q < j$ such that $p$ is $L$ and $q$ is $R$.
  \item There exist no updated indices $p < i$ and $q > j$ such that $(p, q)$ is also a segment.
\end{enumerate}
\end{definition}

More intuitively, a segment is a maximal contiguous region of the array in which all $R$-direction updates precede all $L$-direction updates. The first two conditions define valid segment boundaries, the third enforces the $R^\ast L^\ast$ structure within a segment, and the final condition ensures that segments are maximal and non-overlapping. \figref{fig:segment-structure} illustrates this structure.

\subparagraph{Key Insight: Segments can be fixed \emph{locally} and \emph{independently}.}
\label{sec:insight}

Unlike BIS, where each insertion can be at any point in the array, in DeltaSort, \emph{an updated value in a segment cannot cross its segment boundary}. We formally prove this property next.

\begin{lemma}[Movement Confinement]
\label{lem:confinement}
During Phase~2, all value movement is confined within segment boundaries.
\end{lemma}

\begin{proof}
Let $S$ be a segment with $R$-indices $R_0,\ldots,R_{r-1}$ followed by $L$-indices $L_0,\ldots,L_{l-1}$, where $r+l \ge 1$. After Phase~1, updated values are ordered: $A[R_0] \le \cdots \le A[R_{r-1}] \le A[L_0] \le \cdots \le A[L_{l-1}]$. An $R$-value couldn't have crossed $L_0$ (if it exists), and an $L$-value couldn't have crossed $R_{r-1}$ (if it exists), since the above ordering must be preserved. Therefore, no value exits its segment.
\end{proof}

\begin{remark}
  Note that Lemma~\ref{lem:confinement} also implies \emph{segment independence}. Because no value exits its segment, segment lengths don't change. As a result, movement in a segment does not interfere with movement in another segment, which implies segments can be fixed independently in any order. This opens up opportunities for \textbf{parallelization} that can improve performance even further on multi-core systems and distributed environments. To avoid scope creep, we leave this investigation for future work.
\end{remark}

\subsection{Complexity Analysis}
\label{sec:complexity}

We analyse the expected total data movement incurred during Phase~2 of DeltaSort under a random bounded-range update model. In this model, updated values are drawn uniformly at random from a \emph{fixed} value range. Choosing values at random avoids introducing any special structure that could bias the analysis.

\begin{remark}[Choice of Update Model]
\label{rem:update-model}
Several update models could be considered. For example, a \emph{bounded rank displacement} model constrains updates such that for every updated value $|Rank_{\text{new}} - Rank_{\text{old}}| \le b$ for some bound $b$, while a \emph{clustered update} model restricts updated indices to a region with $u_{\max} - u_{\min} \le c$. Different models interact with DeltaSortâ€™s structure in different ways: bounded displacement directly limits movement and is therefore favorable, whereas clustered updates may either help or hinder performance depending on the induced directional pattern. In this work, we adopt a \emph{random update model} as a neutral baseline. Specifically, updated indices are chosen uniformly at random from $\{0, \ldots, n-1\}$, and updated values are drawn independently from a fixed range of permissible values. This model introduces no additional structure that the algorithm can exploit, nor does it adversarially bias updates towards worst-case configurations (see \figref{fig:worst-case} for an example of a worst case). Analysing DeltaSort under more structured update models is left to future work.
\end{remark}

\input{\figdir/segment-structure}

\begin{lemma}[Expected Movement]
\label{lem:movement-bound}
Under the random bounded-range update model, for an array of size $n$ with $k$ updated indices, the expected total data movement incurred during DeltaSort's Phase~2 is $O(n)$, independent of $k$.
\end{lemma}

\begin{proof}
Consider the sequence of directions induced by the $k$ updated indices after Phase~1. Under the random update model, updated indices are chosen uniformly at random and hence are expected to be evenly distributed across the array. After Phase~1, the updated values are sorted and written back in index order, which enforces the correct order among updated values: for consecutive updated indices $u_\ell < u_i < u_r$, the value at $u_i$ must lie in $[A[u_{\ell}]$,$A[u_r]]$.

For an updated index $u_i$ to be classified as $L$, it must be in the range $[A[u_\ell], A[u_i-1]]$. Similarly, for it to be classified as $R$, it must be in the range $[A[u_i-1], A[u_r]]$. Given the updated indices are distributed uniformly at random, both these intervals are expected to be of equal size on average. Each updated value, randomly chosen, has equal probability to lie in either range. Therefore, each updated index has direction $L$ or $R$ with equal probability $1/2$, independently.

It follows from \defref{def:direction} that segment boundaries occur at $\mathrm{L}\!\to\!\mathrm{R}$ transitions in the direction sequence. For any adjacent pair of updated indices $(i, i+1)$:
\[
\Pr[\mathrm{LR} \text{ at } (i, i+1)] = \Pr[\text{L at } i] \cdot \Pr[\text{R at } i+1] = \frac{1}{2} \cdot \frac{1}{2} = \frac{1}{4}.
\]

With $k-1$ adjacent pairs, the expected number of $\mathrm{L}\!\to\!\mathrm{R}$ transitions is:
\[
\mathbb{E}[\text{LR transitions}] = (k-1) \cdot \frac{1}{4} = \frac{k-1}{4} = \Theta(k).
\]

The expected number of segments is therefore $1 + \Theta(k) = \Theta(k)$. Under uniform index distribution, each segment spans $O(n/k)$ positions in expectation. By \lemref{lem:confinement}, movement is confined within segments, so each updated value moves at most $O(n/k)$ positions. Thus:
\[
\mathbb{E}[\text{total movement}] \le k \cdot O(n/k) = O(n). \qedhere
\]
\end{proof}

\begin{remark}[Worst Case Movement]
While the expected movement is $O(n)$, the worst-case movement can be as high as $O(kn)$. This occurs when all updated values form a single segment spanning the entire array. This happens when updates cluster \emph{monotonically} at the start or end of the array as shown in \figref{fig:worst-case}. Hence, in a practical setting, a hybrid algorithm will need to fallback to ESM or full re-sort based on the number of segments detected after Phase~1.
\input{\figdir/worst-case}
\end{remark}

\begin{lemma}[Comparison Count]
\label{lem:comparison-count}
DeltaSort performs $O(k \log n)$ comparisons.
\end{lemma}

\begin{proof}
Phase~1 sorts the $k$ updated values, requiring $O(k \log k)$ comparisons. In Phase~2, each updated value is fixed using binary search within its containing segment. By \lemref{lem:movement-bound}, the expected width of a segment is $O(n/k)$, and searches are confined within segment boundaries. Therefore, each fix requires $O(\log (n/k))$ comparisons, for a total of $O(k \log (n/k))$ comparisons in Phase~2. Summing both phases gives:
\[
O(k \log k) + O(k \log (n/k)) = O\!\bigl(k(\log k + \log (n/k))\bigr) = O(k \log n).
\]
\end{proof}

\begin{theorem}[Time Complexity]
\label{thm:time-complexity}
Under the random bounded-range update model, DeltaSort runs in $O(k \log n + n)$ expected time.
\end{theorem}

\begin{proof}
By \lemref{lem:movement-bound}, the expected total data movement is $O(n)$. By \lemref{lem:comparison-count}, the total number of comparisons is $O(k \log n)$. Combining these, the expected running time is $O(k \log n + n)$.
\end{proof}

\begin{theorem}[Space Complexity]
\label{thm:space}
DeltaSort uses $O(k)$ auxiliary space.
\end{theorem}

\begin{proof}
Phase~1 stores $k$ updated indices and $k$ updated values. Phase~2 maintains a pending stack of at most $k$ indices. The internal sorting routine is also assumed to use $O(k)$ space. Therefore, the total auxiliary space is $O(k)$.
\end{proof}