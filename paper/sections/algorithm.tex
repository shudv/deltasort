%==============================================================================
\section{DeltaSort Algorithm}
\label{sec:algorithm}
%==============================================================================

\subsection{Overview}

DeltaSort operates in two phases. The first phase establishes a structure among updated values, and the second phase exploits this structure to efficiently sort the array.

\paragraph{Phase 1: Establish structure.} DeltaSort begins by extracting the values at the updated indices, sorting them, and writing them back to the array in increasing index order. This step enforces order among updated positions: if $i < j$ are both updated indices, then $\texttt{cmp}(A[i], A[j]) \le 0$ after Phase~1. This monotonicity implies that any remaining disorder must occur only between updated values and their neighboring elements. Moreover, it induces a simple directional structure on the updated indices, which we formalize next.

\begin{definition}[Direction]
\label{def:direction}
For an updated index $i$, we define its \emph{direction} based on local order:
\begin{itemize}
  \item \textbf{LEFT ($L$)}: Value is ordered incorrectly to it's left neighbour: $i > 0 \text{ and } \texttt{cmp}(A[i-1], A[i]) > 0$
  \item \textbf{RIGHT ($R$)}: Value is either already sorted correctly w.r.t it's neighbours or ordered incorrectly to its right neighbour: $i = 0 \text{ or } \texttt{cmp}(A[i-1], A[i]) \le 0$
\end{itemize}
\end{definition}

\begin{remark}
The definition of direction is deliberately asymmetric. $L$ requires a strict violation ($A[i-1] > A[i]$), while $R$ includes both violating and non-violating cases. DeltaSort treats all $R$ elements identically, so combining these cases simplifies the implementation (see \algoref{alg:deltasort}).
\end{remark}

After Phase~1, updated indices group into \emph{segments}, which we define next.

\begin{definition}[Segment]
\label{def:segment}
A \emph{segment} is a pair of indices $(i, j)$ with $i < j$ such that:
\begin{enumerate}
  \item Either $i = 0$, or $i \in U$ has direction $R$.
  \item Either $j = n - 1$, or $j \in U$ has direction $L$.
  \item There exist no updated indices $p, q \in U$ with $i < p < q < j$ such that $p$ has direction $L$ and $q$ has direction $R$.
  \item There exist no updated indices $p < i$ and $q > j$ such that $(p, q)$ also satisfies the above conditions.
\end{enumerate}
\end{definition}

Intuitively, a segment is a maximal contiguous region of the array in which all $R$-direction updates precede all $L$-direction updates. The first two conditions define valid segment boundaries, the third enforces the $R^\ast L^\ast$ structure within a segment, and the final condition ensures that segments are maximal and non-overlapping. \figref{fig:segment-structure} illustrates this structure.

\input{\figdir/segment-structure}

\paragraph{Phase 2: Sort.}
With the above structure in place, DeltaSort repairs the array segment by segment. Within each segment, updated indices are processed in increasing index order. For each segment, the algorithm maintains two repair boundaries:
a left boundary $\ell$ beyond which the $L$-values cannot move and a right boundary $r$ beyond which the $R$-values cannot move.

\begin{enumerate}
  \item At the start of a segment, the left boundary $\ell$ is initialized to the segment's left endpoint.
  \item As the algorithm scans updated indices from left to right, indices with direction $R$ are pushed onto a stack.
  \item When the first $L$-direction index at position $i$ is encountered or the end of the segment is reached, the right boundary $r$ is initialized to $i$. All deferred $R$ indices are then repaired in LIFO order. Each $R$ value with index $i$ is fixed using binary insertion within the range $[i, r]$, after which $r$ is advanced to the left beyond the insertion position.
  \item After all deferred $R$ values have been repaired, $L$ values are repaired in left-to-right order. Each $L$ value at index $i$ is fixed using binary insertion within the range $[\ell, i]$, after which the left boundary $\ell$ is advanced to the right beyond the insertion position.
\end{enumerate}

Importantly, the binary search ranges for $L$ and $R$ fixes are always within the current segment boundaries.Figure~\ref{fig:delta-sort-example} illustrates this process for a sample array.

\input{\figdir/delta-sort-example}

\subsection{Key Insight: Segments can be repaired locally and independently}
\label{sec:insight}

The key insight behind DeltaSort is that segments created after Phase~1 can be fixed locally. Unlike Binary-Insertion-Sort, where each insertion can be at any point in the array, an updated value in a segment cannot cross it's segment boundary. We formally prove this property next.

\begin{lemma}[Direction Invariance]
\label{lem:direction-invariance}
After Phase~1, each updated value moves only in the direction indicated by its direction label:
\begin{itemize}
  \item Values with direction $L$ \textbf{must} move to the left.
  \item Values with direction $R$ \textbf{may} \footnote{This assymetry follows from the definition of direction (Definition~\ref{def:direction}).} move to the right.
\end{itemize}
\end{lemma}

\begin{proof} Consider an updated index $i$. If $i$ has direction $R$, then by definition either $i = 0$ or $\texttt{cmp}(A[i-1], A[i]) \le 0$. After Phase~1, updated values are written back in sorted order by index, so all updated values to the left of $i$ are less than or equal to $A[i]$. All unchanged values to the left were already in sorted order. Hence, no value to the left of $i$ exceeds $A[i]$, and $A[i]$ cannot move left during Phase~2. The argument for direction $L$ is symmetric.
\end{proof}

\begin{lemma}[Movement Confinement]
\label{lem:confinement}
During Phase~2, all value movement is confined within segment boundaries.
\end{lemma}

\begin{proof}
Let $S$ be a segment with $R$-indices
$R_0,\ldots,R_{r-1}$ followed by $L$-indices
$L_0,\ldots,L_{l-1}$, where $r+l \ge 1$.
After Phase~1,
\[
A[R_0] < \cdots < A[R_{r-1}] < A[L_0] < \cdots < A[L_{l-1}].
\]

By Lemma~\ref{lem:direction-invariance}, $R$-values move only rightward and $L$-values move only leftward. An $R$-value cannot cross $L_0$ (if it exists), and an $L$-value cannot cross $R_{r-1}$ (if it exists), since the above ordering is preserved. Therefore, no value exits its segment.
\end{proof}

\begin{remark}
  Note that Lemma~\ref{lem:confinement} also implies \emph{segment independence}. Because no value exits its segment, segment lengths don't change. As a result, movement in a segment does not interfere with movement in another segment, which implies segments can be repaired independently in any order. This opens up opportunities for \textbf{parallelization}, which can improve performance even further on multi-core systems or distributed environments. To avoid scope creep, we leave this investigation for future work.
\end{remark}

\subsection{Pseudocode}

\input{\figdir/pseudocode}

\subsection{Correctness Proof}

\begin{lemma}[Fix Invariant]
\label{lem:fix-invariant}
Each fix operation during Phase~2 resolves an order violation without introducing new ones.
\end{lemma}

\begin{proof}
We fix each violation using binary search. For binary search to find the correct insertion point, the search range must contain no violations.
\begin{itemize}
    \item \emph{L fix at index $i$}: The search range $[leftBound, i-1]$ contains no L violations because Ls are processed left-to-right, and no R violations because all pending Rs are flushed before any L is fixed.
    \item \emph{R fix at index $i$}: The search range $[i+1, rightBound]$ contains no R violations because Rs are processed in LIFO order with $rightBound$ narrowing after each fix, and no L violations because $rightBound$ never extends past the first L in the segment.
\end{itemize}
\end{proof}

\begin{theorem}[Correctness]
\label{thm:correctness}
DeltaSort produces a correctly sorted array.
\end{theorem}

\begin{proof}
The only violations in the array after Phase~1 are at updated indices. Phase~2 processes each updated index exactly once. By \lemref{lem:fix-invariant}, each fix resolves a violation without introducing new ones. After all fixes, no violations remain, so the array is sorted.
\end{proof}

\subsection{Complexity Analysis}
\label{sec:complexity}

We analyze the expected total data movement incurred during Phase~2 of DeltaSort under a random bounded-range update model. In this model, updated values are drawn randomly and uniformly from a \emph{fixed} value range. Choosing values at random avoids introducing any special structure that could bias the analysis.

\begin{remark}[Choice of Update Model]
\label{rem:update-model}
Several update models could be considered. For example, a \emph{bounded rank displacement} model constrains updates such that for every updated element $|Rank_{\text{new}} - Rank_{\text{old}}| \le b$ for some bound $b$, while a \emph{clustered update} model restricts updated indices to a region with $u_{\max} - u_{\min} \le c$. Different models interact with DeltaSortâ€™s structure in different ways: bounded displacement directly limits
movement and is therefore favorable, whereas clustered updates may either help
or hinder performance depending on the induced directional pattern.

In this work, we adopt a fully random update model as a neutral baseline. Specifically, updated indices are chosen uniformly at random from $\{0, \ldots, n-1\}$, and updated values are drawn independently from a fixed range of permissible values. This model introduces no additional structure that the algorithm can explicitly exploit, nor does it adversarially bias updates towards worst-case configurations (see Appendix~\appref{sec:appendix-ds-worst-case} for an example of a worst case). Analyzing DeltaSort under more structured update models, including bounded displacement and clustered updates,
is left to future work.
\end{remark}

\begin{theorem}[Expected Linear Movement]
\label{thm:movement-bound}
Under the bounded-range update model, for an array of size $n$ with $k$ updated indices, the expected total data movement incurred during DeltaSort's repair phase is $O(n)$, independent of $k$.
\end{theorem}

\begin{proof}[Proof sketch]
Under the bounded-range model, the probability of direction L at the $i$-th updated index is $i/(k-1)$, and R is $(k-1-i)/(k-1)$. Segment boundaries occur at $\mathrm{L}\!\to\!\mathrm{R}$ transitions. By summing the transition probabilities over adjacent pairs, we show that the expected number of such transitions is $\Theta(k)$, yielding $\Theta(k)$ segments. Each segment spans $O(n/k)$ positions in expectation, and by \lemref{lem:confinement}, movement is confined within segments. Thus, total expected movement is $k \cdot O(n/k) = O(n)$. The full derivation appears in \appref{sec:appendix-proof}.
\end{proof}

\begin{theorem}[Comparison Count]
\label{thm:comparison-count}
DeltaSort performs $O(k \log n)$ comparisons, which is asymptotically optimal.
\end{theorem}

\begin{proof}
Phase~1 sorts the $k$ updated values, requiring $O(k \log k)$ comparisons. In Phase~2, each updated value is repaired using a binary search within its containing segment. By \thmref{thm:movement-bound}, the expected width of a segment is $O(n/k)$, and searches are confined within segment boundaries. Therefore, each repair requires $O(\log (n/k))$ comparisons, for a total of $O(k \log (n/k))$ comparisons in Phase~2. Summing both phases gives-
\[
O(k \log k) + O(k \log (n/k)) = O\!\bigl(k(\log k + \log (n/k))\bigr) = O(k \log n).
\]
\end{proof}

\begin{theorem}[Space Complexity]
\label{thm:space}
DeltaSort uses $O(k)$ auxiliary space.
\end{theorem}

\begin{proof}
Phase~1 stores $k$ updated indices and $k$ updated values. Phase~2 maintains a pending stack of at most $k$ indices.
\end{proof}
