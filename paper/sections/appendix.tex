\appendix

\section{Full Proof of Expected Linear Movement}
\label{sec:appendix-proof}

We provide the complete derivation for \thmref{thm:movement-bound}.

\begin{proof}
Consider the sequence of directions induced by the $k$ updated indices after Phase~1. Let position $i \in \{0, \ldots, k-1\}$ denote the $i$-th updated index. Under the bounded-range update model, an updated value is equally likely to fall anywhere within the global value range. The probability that position $i$ has direction L is proportional to the number of preceding updates, and R proportional to the number following:
\[
\Pr[\text{L at position } i] = \frac{i}{k-1},
\qquad
\Pr[\text{R at position } i] = \frac{k-1-i}{k-1}.
\]

Segment boundaries occur at $\mathrm{L}\!\to\!\mathrm{R}$ transitions. For adjacent positions $(i, i+1)$:
\[
\Pr[\mathrm{LR} \text{ at } (i, i+1)] = \frac{i}{k-1} \cdot \frac{k-2-i}{k-1} = \frac{i(k-2-i)}{(k-1)^2}.
\]

Summing over all adjacent pairs:
\[
\mathbb{E}[\mathrm{LR\ transitions}] = \sum_{i=0}^{k-2} \frac{i(k-2-i)}{(k-1)^2} = \frac{1}{(k-1)^2} \sum_{i=0}^{k-2} i(k-2-i).
\]

Using the identity $\sum_{i=0}^{m} i(m-i) = \frac{m(m+1)(m-1)}{6}$ with $m = k-2$:
\[
\sum_{i=0}^{k-2} i(k-2-i) = \frac{(k-2)(k-1)(k-3)}{6},
\]
and therefore:
\[
\mathbb{E}[\mathrm{LR\ transitions}] = \frac{(k-2)(k-3)}{6(k-1)} = \Theta(k).
\]

The expected number of segments is $1 + \Theta(k) = \Theta(k)$. Under uniform index distribution, each segment spans $O(n/k)$ positions. By \lemref{lem:confinement}, movement is confined within segments, so:
\[
\mathbb{E}[\text{total movement}] \le k \cdot O(n/k) = O(n). \qedhere
\]
\end{proof}

\section{Comparison Count}
\label{sec:appendix-comparisons}


\figref{fig:rust-comparator-count} shows the total number of comparisons as a function of update count $k$. We have used a realistic multi-key comparator that compares user objects by (country, age, name) to reflect practical comparison costs.

\input{\figdir/rust/comparator-count}

Several clear patterns emerge:

\begin{enumerate}
  \item \textbf{Asymptotic behavior matches theory}: The observed comparator counts closely follow the  expected asymptotic trends for all algorithms across the full range of $k$.

  \item \textbf{ESM incurs high comparison cost even for small updates}: Due to the full merge step, ESM performs a large number of comparisons even when $k$ is small.

  \item \textbf{DeltaSort matches BIS asymptotically}: DeltaSort's comparator count closely tracks BIS for $k \lesssim 1\%$ and remains within $\approx 10$--$20\%$ of BIS for larger $k$, while preserving the same $O(k \log n)$ asymptotic behavior. Note that for large $k$, even though BIS is most comparison-efficient, its data movement cost makes it an impractical choice.
\end{enumerate}

The key takeaway is that DeltaSort, like BIS, substantially reduces redundant comparison work relative to ESM and NativeSort. As comparator cost increases, this advantage would becomes more pronounced. For small update ranges, where BIS and DeltaSort have similar comparison counts, DeltaSort's movement efficiency becomes the dominant factor, and its relative advantage over BIS will persist across a wide range of comparator costs.


\section{DeltaSort vs ESM Crossover Threshold}
\label{sec:appendix-rust-ds-vs-esm}

\input{\figdir/rust/crossover-ds-vs-esm}

\figref{fig:rust-crossover-ds-vs-esm} shows that there exists a non-trivial regime in which DeltaSort dominates ESM both in execution time and space usage. For example, for an array of size $n = 100$K, DeltaSort outperforms ESM for up to $\approx 1K$ updates, while using only $\approx 1\%$ of the auxiliary space required by ESM. As array size increases, this regime steadily shrinks. For large arrays, the crossover threshold moves toward smaller fractions, indicating that DeltaSort loses to ESM earlier. Although both algorithms incur $O(n)$ data movement in the worst case, this trend suggests that the constant factors associated with DeltaSort's movement become more pronounced at larger scales. As a result, ESM's simpler linear merge begins to dominate for smaller $k$ as $n$ grows.

\section{Crossover Thresholds in JavaScript}
\label{sec:appendix-js}

\figref{fig:js-crossover-all} and~\figref{fig:js-crossover-ds-vs-esm} show crossover thresholds for the JavaScript implementation.

\input{\figdir/js/crossover-all}

\input{\figdir/js/crossover-ds-vs-esm}

\paragraph{Observations.} In JavaScript, crossover thresholds are generally lower than in Rust due to the managed runtime's memory movement behavior. BIS and DeltaSort have almost identical behavior in JavaScript, while ESM maintains a higher threshold ($\approx 35$--$40\%$). This implies that for small $k$, BIS is preferable to DeltaSort in JavaScript because of lower space requirement and simpler implementation, unlike in Rust where DeltaSort has a clear measurable advantage.
