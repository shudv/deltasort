%==============================================================================
\section{Problem Model}
\label{sec:model}
%==============================================================================

\begin{definition}[Update-Aware Sorting]
\label{def:problem}
Let $A[0..n-1]$ be an array of size $n$ sorted according to a strict weak ordering defined by a comparator $\texttt{cmp}$. Let $U = \langle u_0, u_1, \dots, u_{k-1} \rangle$ be a sequence of $k$ indices such that \[ 0 \le u_0 < u_1 < \dots < u_{k-1} \le n-1, \] and the values at these indices may have been arbitrarily updated \footnote{ This can handle to insertions and deletions as well. Insertions can be handled by appending the new element and marking its index as updated. Deletions can be reduced to updates by assigning a sentinel value larger than all values and truncating the array after repair.}, while values at all other indices remain unchanged. The \emph{update-aware sorting problem} is to restore $A$ to a state that is sorted with respect to $\texttt{cmp}$, given explicit knowledge of the set $U$.
\end{definition}

This model assumes that the indices of updated values are available to the sorting primitive, which requires the caller to record the $k$ updated indices and thus incurs an O(k) space overhead. This overhead is modest and aligns with how updates are applied in practice: locating and modifying a value already requires identifying its position, and recording that position incurs only constant additional cost per update. In contrast, avoiding this bookkeeping typically forces the system to fall back to either full re-sorting, which incurs $O(n \log n)$ time, or Binary-Insertion-Sort, which is comparison-efficient but suffers from $O(kn)$ data movement. Modern streaming and stateful processing systems routinely track update deltas as part of their execution pipeline, making the update-aware model a natural and practical abstraction rather than an artificial one.