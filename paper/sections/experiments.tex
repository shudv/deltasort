%==============================================================================
\section{Experimental Evaluation}
\label{sec:experiments}
%==============================================================================

All benchmarks \footnote{Along with benchmarks, we also validated correctness by an extensive set of randomized tests~\cite{deltasort-repo} across various scales of $n$ and full range of $k$.} are evaluated on Rust implementations of each algorithm on synthetic datasets of user objects (name, age, country) on an Apple M series chip. We use Rust as the primary evaluation language due to its predictable performance characteristics \footnote{In contrast, managed execution environments like JavaScript on V8 have various factors like garbage collection, non-contiguous memory layouts~\cite{v8elementskinds} etc. that impact the underlying cost model.}. We used a realistic multi-key comparator to simulate a practical workload. Execution times are measured after sufficient warm-up iterations to account for caching and allocator effects. Each reported data point corresponds to the mean over repeated runs, with a 95\% confidence interval of at most $5\%$. All the source code used for benchmarking is provided in the repository for reproducibility~\cite{deltasort-repo}. We used fully random update distributions, which provide no exploitable structure to any particular algorithm. We evaluated the following algorithms:

\begin{itemize}
  \item \textbf{FullSort}: Rust's stable \texttt{slice::sort\_by} implementation based on DriftSort~\cite{driftsort}, representing full re-sorting of the array. This serves as a critical baseline to identify the crossover threshold $k_c$ for each update-aware algorithm beyond which FullSort becomes preferable.

  \item \textbf{BIS} and \textbf{ESM}: Standard Rust implementations that adhere to the time--space trade-offs as described in \secref{sec:introduction}. ESM internally uses Rust's \texttt{slice::sort\_by} for sorting updated values.

  \item \textbf{DeltaSort}: Standard implementation as described in \secref{sec:algorithm}. Like ESM, it also uses Rust's \texttt{slice::sort\_by} internally for sorting updated values.
\end{itemize}

\input{\figdir/sorting-algorithms}

\subsection{Execution Time}

\figref{fig:rust-execution-time} shows execution time (in \textmu s) for $n = 100$K values as a function of the number of updated values $k$ on a log--log scale. We use a log--log scale to highlight interesting behavior at lower ranges of $k$, which is the most practically relevant range, since updates typically affect only a small fraction of an array at once. As $k$ increases, all update-aware algorithms eventually lose to FullSort (\emph{crossover threshold}), as the overhead of processing updates begins to overshadow any benefit from knowing what updated.

\input{\figdir/rust/execution-time}

Several observations emerge from the execution-time profile:

\begin{enumerate}
  \item The \textbf{asymptotic behavior for each algorithm aligns with theoretical expectations}. BIS exhibits steep growth consistent with its $O(kn)$ movement cost, quickly becoming impractical as $k$ increases. ESM is relatively flat for small $k$, where linear merge cost dominates and is largely independent of the number of updates. DeltaSort exhibits intermediate growth because its execution time scales linearly in $k$ (the $O(k \log n)$ term). ESM and DeltaSort both converge towards FullSort's performance as $k$ approaches $n$, which is expected as they internally use the FullSort routine for sorting all the $k$ updated values.

  \item \textbf{DeltaSort is the fastest baseline for} $k \lesssim 1\%$. It uses more auxiliary space than BIS ($O(k)$ vs $O(1)$) but substantially less than ESM ($O(k)$ vs $O(n)$). Even though $1\%$ is small in absolute terms, it aligns very well with practical workloads where updates are usually a small percentage of the full dataset.

  \item ESM is the fastest baseline across most of the intermediate range ($1\% \lesssim k \lesssim 80\%$). However, its performance comes at the cost of $O(n)$ auxiliary space. \textbf{DeltaSort provides a more space-efficient alternative to ESM for} $k \lesssim 20\%$, while still beating FullSort.
\end{enumerate}

These observations suggest that, much like hybrid blind sorting algorithms (e.g., TimSort~\cite{timsort}, DriftSort~\cite{driftsort}), it would be beneficial to construct \emph{hybrid adaptive update-aware} strategies. As an example, for the Rust implementation evaluated here, a hybrid strategy for an environment that requires fast execution without excessive space usage could be:

\begin{center}
  Use DeltaSort for $k \lesssim 10\%$, ESM for $20\% \lesssim k \lesssim 70\%$, and FullSort for $k \gtrsim 70\%$.
\end{center}

The optimal crossover thresholds for a scenario would depend on several factors like memory availability, distribution of update sizes, comparator cost etc. While we haven't analysed each of these factors, we did evaluate the comparison count for all algorithms. Empirically, DeltaSort’s comparator invocation count closely tracks that of BIS, consistent with its $O(k \log n)$ theoretical bound. Consequently, \emph{in scenarios where comparator cost dominates, DeltaSort preserves its advantage over BIS while further widening the performance gap relative to Extract–Sort–Merge, whose comparison overhead is substantially higher}. This effect \emph{shifts crossover thresholds in favor of DeltaSort} and expands the range of update sizes for which it is the preferred strategy. Detailed comparison counts for all algorithms are reported in Appendix~\ref{sec:appendix-comparisons}.

\subsection{Crossover Threshold}

\input{\figdir/rust/crossover-all}
\figref{fig:rust-crossover-all} shows the crossover thresholds ($k_c$) for all the update-aware algorithms. A larger threshold means that the algorithm remains faster than full re-sorting for larger update sizes. Several observations stand out:

\begin{enumerate}
  \item BIS has a very low crossover threshold due to its $O(kn)$ data movement cost, whereas ESM achieves the highest crossover threshold consistent with its $O(n + k \log k)$ time complexity, which is asymptotically the best among all alternatives.

  \item DeltaSort exhibits an \emph{intermediate threshold}, aligning with its $O(k \log n)$ time complexity, which interpolates between the two extremes.
  
  \item Thresholds are largely stable across different scales (DeltaSort $20--35\%$, ESM $60--80\%$), although we observe a decline for very large arrays ($n \gtrsim 200$K). This may be an artifact of practical limits on devices. More study is needed to understand this behavior in detail.
\end{enumerate}

The key takeaway is that DeltaSort occupies a well-defined ground among update-aware algorithms. It supports much larger update batches than BIS while requiring much less auxiliary space than ESM, making it a compelling choice where both time and space constraints matter.

\subsection{Performance in managed execution environments}

DeltaSort was also implemented in JavaScript~\cite{deltasort-repo} and benchmarked on Node v22 against the native \texttt{Array.prototype.sort} to evaluate behavior in managed runtimes. The key takeaway is that DeltaSort's performance benefits rely on a \emph{predictable movement cost model}, which holds in low-level, unmanaged environments (e.g., Rust) but not in V8~\cite{v8elementskinds} (see \appref{sec:appendix-js-deltasort} for more details).