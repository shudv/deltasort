%==============================================================================
\section{Experimental Evaluation}
\label{sec:experiments}
%==============================================================================

\input{\figdir/sorting-algorithms}

All benchmarks \footnote{Along with benchmarks, we also validated correctness by an extensive set of randomized tests~\cite{deltasort-repo} across various scales of $n$ and full range of $k$.} are run on Rust implementations of each algorithm on randomly generated synthetic datasets of user objects (name, age, country) on an Apple M series chip. We chose Rust due to its predictable performance characteristics \footnote{In contrast, managed execution environments like JavaScript on V8 have various factors like garbage collection, non-contiguous memory layouts~\cite{v8elementskinds} etc. that impact the underlying cost model.}. We used a realistic multi-key comparator to simulate a practical workload. Execution times are measured after sufficient warm-up, and each data point is the mean over repeated runs with 95\% CI within $5\%$. All the source code is available for reproducibility~\cite{deltasort-repo}.

We evaluated the following algorithms:
\begin{itemize}
  \item \textbf{FullSort}: Rust's stable \texttt{slice::sort\_by} implementation based on DriftSort~\cite{driftsort}, representing full re-sorting of the array. This serves as a critical baseline to identify the crossover threshold $k_c$ for each update-aware algorithm beyond which FullSort is preferable.

  \item \textbf{BIS} and \textbf{ESM}: Standard Rust implementations that adhere to the time--space trade-offs as described in \secref{sec:introduction}. ESM internally uses Rust's \texttt{slice::sort\_by}.

  \item \textbf{DeltaSort}: Standard implementation as described in \secref{sec:algorithm}. Like ESM, it also uses Rust's \texttt{slice::sort\_by} internally for sorting updated values.
\end{itemize}

\subsection{Results}

\input{\figdir/rust/performance}

\figref{fig:rust-performance}(a) shows execution time (in \textmu s) for $n = 100$K values as a function of percentage of updated values on a log--log scale. We use a log--log scale to highlight interesting behavior at lower ranges of $k$, which is the most practically relevant range, since updates typically affect only a small fraction of an array at once. As $k$ increases, all update-aware algorithms eventually lose to FullSort at a critical crossover threshold $k_c$, as the overhead of processing updates overshadows any benefit from knowing what was updated. \figref{fig:rust-performance}(b) shows how $k_c$ varies for each algorithm across various scales. Several observations emerge:

\begin{enumerate}
  \item The asymptotic behavior for each algorithm aligns with theory. BIS exhibits steep growth consistent with its $O(kn)$ movement cost, quickly becoming impractical as $k$ increases. ESM is relatively flat for small $k$, where linear merge cost dominates and is largely independent of the number of updates. DeltaSort exhibits intermediate growth.

  \item \textbf{DeltaSort is the fastest algorithm for} $k \lesssim 1\%$. For example, at $k = 0.1\%$, DeltaSort is $\sim$10$\times$ faster than FullSort, $\sim$3$\times$ faster than ESM and $\sim$15$\times$ faster than BIS. It uses more auxiliary space than BIS ($O(k)$ vs $O(1)$) but substantially less than ESM ($O(k)$ vs $O(n)$). Even though $1\%$ is small in absolute terms, it aligns very well with practical workloads where updates usually affect only a small percentage of the full dataset.

  \item ESM is the fastest algorithm across most of the intermediate range ($1\% \lesssim k \lesssim 70\%$). However, its performance comes at the cost of $O(n)$ space. \textbf{DeltaSort provides a space-efficient alternative to ESM for} $k \lesssim 20\%$, using $\sim$5--10$\times$ less space while still beating FullSort by $\sim$2$\times$.
  
  \item Crossover threshold trend is consistent and largely stable across all scales (DeltaSort 20--40\%, ESM 60--80\%), indicating that \textbf{the above observations hold across scales}. BIS has a very low threshold due to its quadratic data movement cost, whereas ESM has the highest threshold due to its efficient linear merge pass. DeltaSort exhibits an intermediate threshold, in line with its intermediate time complexity.
\end{enumerate}

These observations suggest that, much like hybrid blind sorting algorithms (e.g., TimSort~\cite{timsort}, DriftSort~\cite{driftsort}), it would be beneficial to construct \emph{adaptive update-aware} strategies. As an example, for the Rust implementation evaluated here, an adaptive strategy for an environment that requires fast execution without excessive space usage could be: use DeltaSort for $k \lesssim 10\%$, ESM for $20\% \lesssim k \lesssim 70\%$, and FullSort for $k \gtrsim 70\%$. The optimal cut-off points for a scenario would depend on several factors like memory availability, distribution of update sizes, comparator cost etc. For example, as the comparator cost grows, DeltaSort preserves its advantage over BIS because both have similar comparison count: $O(k \log n)$, while widening its gap relative to ESM, which has substantially higher comparison overhead. Hence, the crossover thresholds would shift in favor of DeltaSort, expanding the range of update sizes for which it is the preferred strategy.

\subsection{Performance in V8 runtime}

DeltaSort was also implemented in JavaScript~\cite{deltasort-repo} and benchmarked on V8 against the native \texttt{Array.prototype.sort} to evaluate behavior in a runtime that \emph{does not have a predictable movement cost model}~\cite{v8elementskinds}. The key takeaways are:
\begin{enumerate}
  \item DeltaSort's performance is identical to BIS and has a \textbf{much lower crossover threshold} (see~\appref{sec:appendix-js-deltasort} for benchmarks), which shows that the improvements seen in native environments like Rust, \textbf{do not translate to V8}.

  \item BIS and DeltaSort are $\sim$10$\times$ faster than FullSort for $k\lessapprox0.01\%$ and ESM is $\sim$1.4$\times$ faster than FullSort for $k$ up to $\approx$50\%, indicating that even in managed runtimes, \emph{exposing updated indices can unlock better performance}.
\end{enumerate}
