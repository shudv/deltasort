%==============================================================================
\section{Problem Model}
\label{sec:model}
%==============================================================================

\begin{definition}[Update-Aware Sorting]
\label{def:problem}

Let $A[0..n-1]$ be an array of size $n$ that is initially sorted according to a strict weak ordering induced by a comparator $\texttt{cmp}$. Let $U \subseteq \{0,\dots,n-1\}$ be a set of $k$ distinct indices such that the values at indices in $U$ may have been arbitrarily updated\footnote{This model can be easily extended to insertions and deletions as well. Insertions can be handled by appending the new value to the end of the array and adding $n$ to $U$. Deletions can be reduced to updates by assigning a sentinel value larger than all existing values and truncating the array after sorting.}, while values at all other indices remain unchanged. The \emph{update-aware sorting problem} is to restore the global sorted order of $A$ with respect to $\texttt{cmp}$, given explicit knowledge of the update set $U$.
\end{definition}

The sorting primitive in this model requires the caller to store the $k$ updated indices incurring an extra $O(k)$ space overhead compared to full re-sorting. This overhead is modest and aligns with how updates are applied in practice: locating and updating a value already requires identifying its position, and recording that position incurs only constant additional cost per update. In contrast, avoiding this bookkeeping typically forces the system to fall back to either full re-sorting, which incurs $O(n \log n)$ time cost per update, or BIS, which incurs $O(n)$ data movement cost per update. Modern streaming and stateful processing systems~\cite{kleppmann2017ddiamodernsystems} routinely track update deltas as part of their execution pipelines, making the update-aware model a natural and practically useful abstraction.